<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Machine Learning Book</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="src/scientific.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Chapter 1</a></li><li class="chapter-item expanded "><a href="2_intro.html"><strong aria-hidden="true">2.</strong> Introduction to Machine Learning with Rust</a></li><li class="chapter-item expanded "><a href="3_kmeans.html"><strong aria-hidden="true">3.</strong> Getting Started With The KMeans Algorithm</a></li><li class="chapter-item expanded affix "><a href="bibliography.html">Bibliography</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust Machine Learning Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#chapter-1" id="chapter-1">Chapter 1</a></h1>
<p>A simple demonstration of latex and gnuplot integration into <code>mdbook</code>.</p>
<figure id="hyperplane" class="figure"><object data="assets/dee8de7ccbf9223918d21410.svg" type="image/svg+xml"/></object><figcaption>Figure 1.1 Influence of an outlier to the separating hyperplane, note that a single support vector changes the border completely</figcaption></figure>
<p>This is a test to 
<a class="fig_ref" href='#hyperplane'>Figure 1.3</a>
blub.</p>
<div id="svm" class="equation"><div class="equation_inner"><object data="assets/d36d2f91a62a9e32d4bdb7d7.svg" type="image/svg+xml"></object></div><span>(1.1)</span></div>
<figure id="contour" class="figure"><object data="assets/e9ea986c569b3a41be529169.svg" type="image/svg+xml"/></object><figcaption>Figure 1.2 Contour test plot</figcaption></figure>
<p>We should reference this 
<a class="bib_ref" href='bibliography.html#legendreintegral'>[1]</a>
and inline math 
<object class="equation_inline" data="assets/de566924d07db43d343b3454.svg" type="image/svg+xml"></object>
should also work and this 
<a class="equ_ref" href='#svm'>Eq. (1.2)</a>
.</p>
<pre><code># Chapter 1

A simple demonstration of latex and gnuplot integration into `mdbook`.

&lt;figure id=&quot;hyperplane&quot; class=&quot;figure&quot;&gt;&lt;object data=&quot;assets/dee8de7ccbf9223918d21410.svg&quot; type=&quot;image/svg+xml&quot;/&gt;&lt;/object&gt;&lt;figcaption&gt;Figure 1.3 Influence of an outlier to the seperating hyperplane, note that a single support vector changes the border completely&lt;/figcaption&gt;&lt;/figure&gt;

This is a test to 
&lt;a class=&quot;fig_ref&quot; href='#hyperplane'&gt;Figure 1.3&lt;/a&gt;
 blub.

&lt;div id=&quot;svm&quot; class=&quot;equation&quot;&gt;&lt;div class=&quot;equation_inner&quot;&gt;&lt;object data=&quot;assets/d36d2f91a62a9e32d4bdb7d7.svg&quot; type=&quot;image/svg+xml&quot;&gt;&lt;/object&gt;&lt;/div&gt;&lt;span&gt;(1.2)&lt;/span&gt;&lt;/div&gt;


&lt;figure id=&quot;contour&quot; class=&quot;figure&quot;&gt;&lt;object data=&quot;assets/e9ea986c569b3a41be529169.svg&quot; type=&quot;image/svg+xml&quot;/&gt;&lt;/object&gt;&lt;figcaption&gt;Figure 1.4 Contour test plot&lt;/figcaption&gt;&lt;/figure&gt;


We should reference this 
&lt;a class=&quot;bib_ref&quot; href='bibliography.html#legendreintegral'&gt;[1]&lt;/a&gt;
 and inline math 
&lt;object class=&quot;equation_inline&quot; data=&quot;assets/de566924d07db43d343b3454.svg&quot; type=&quot;image/svg+xml&quot;&gt;&lt;/object&gt;
 should also work and this 
&lt;a class=&quot;equ_ref&quot; href='#svm'&gt;Eq. (1.2)&lt;/a&gt;
.
</code></pre>
<h1><a class="header" href="#introduction-to-machine-learning-with-rust" id="introduction-to-machine-learning-with-rust">Introduction to Machine Learning with Rust</a></h1>
<h2><a class="header" href="#what-is-this-book-for" id="what-is-this-book-for">What is this book for?</a></h2>
<p>This book aims to provide an accessible introduction to machine learning and data science in the Rust ecosystem. Each chapter will have the description of an algorithm, and walk through a code example from start to finish.</p>
<h2><a class="header" href="#who-is-this-book-for" id="who-is-this-book-for">Who is this book for?</a></h2>
<p>This book is written with two primary audiences in mind: developers who are familiar with machine learning and want to write their code Rust, and developers who are familiar with Rust and want to do some machine learning.</p>
<p>In both cases, we generally assume a basic level of understanding of the Rust programming language, although mastery is certainly not required! If you're brand new to the language, it's suggested to start off by reading <a href="https://doc.rust-lang.org/book/"><em>The Rust Programming Language</em></a>, then returning when you feel a little more comfortable. In particular, it's worth reviewing the sections on <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">ownership</a>, <a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">error handling</a>, and <a href="https://doc.rust-lang.org/book/ch13-00-functional-features.html">functional features</a>. Perhaps just as importantly as Rust's syntax, a familiarity with the library/crates ecosystem and documentation practices will prove very valuable. Machine learning in many cases sits near the top of the stack; especially when one is working with data, there are usually several layers of code beneath what the top one is doing. That's one of the benefits of working in Rust; these lower layers are often also written in Rust, which makes the abstraction more transparent and empowers developers to dig fearlessly into the underlying aspects of these programs.</p>
<p>Conversely, we don't assume an in-depth knowledge of machine learning (i.e. mathematical familiarity of the field). Some familiarity with the algorithms may be helpful, but the descriptions and code contained in here should help to build a foundation of some of these topics.</p>
<h2><a class="header" href="#how-to-use-this-book" id="how-to-use-this-book">How to use this book</a></h2>
<p>Each chapter's code sample will be available in its entirety in the <code>code/</code> directory, and can be run independently of the book. For example, to run the entirety of the code example for the KMeans algorithm, the steps would look like the following:</p>
<pre><code class="language-bash">user@computer:~/rust-ml/book cd code/
user@computer:~/rust-ml/book/code cargo run --release --example kmeans
</code></pre>
<h2><a class="header" href="#an-additional-note" id="an-additional-note">An additional note</a></h2>
<p>Like much of Rust, many of the libraries in this ecosystem empower people to write code that they might otherwise not feel able to write otherwise. Machine learning provides a really interesting and useful set of tools. That is a great benefit! However, as the saying goes, with great power comes great responsibility. This means that <strong>it is the responsibility of each developer individually, and the community as a whole, to make sure that the code we write is not being used in harmful ways and make ethical decisions surrounding our work.</strong></p>
<p>As a start, we suggest making yourself familiar with some of the resources that have been collected by the Institute for Ethical Machine Learning <a href="https://github.com/EthicalML/awesome-artificial-intelligence-guidelines">here</a>.</p>
<h2><a class="header" href="#getting-started-with-the-k-means-clustering-algorithm" id="getting-started-with-the-k-means-clustering-algorithm">Getting Started With The K-Means Clustering Algorithm</a></h2>
<h3><a class="header" href="#what-is-kmeans" id="what-is-kmeans">What is KMeans?</a></h3>
<p>KMeans is one of the most common clustering algorithms, where a set of unlabeled data points are grouped into a set of clusters such that each data point is part of the cluster with the centroid nearest to itself.</p>
<p>The centroid of a cluster is calculated as the mean, or average, of the points assigned to that cluster. The <a href="https://github.com/rust-ml/linfa"><code>linfa</code></a> crate provides an implementation of the standard algorithm for this process, known as &quot;Lloyd's algorithm.&quot;</p>
<p>KMeans is_iterative_, meaning that it progressively refines the points assigned to each cluster, and therefore a new centroid for that cluster (leading to new points being assigned to it) during each successive iteration. At a high level, there are three main steps to the algorithm:</p>
<ol>
<li><strong>Initialisation</strong>: Choose our initial set of centroids--this can happen randomly or be set by the user, but the number of clusters/centroids is always defined ahead of time in KMeans</li>
<li><strong>Assignment</strong>: Assign each observation to the nearest cluster (minimum distance between the observation and the cluster's centroid);</li>
<li><strong>Update</strong>: Recompute the centroid of each cluster.</li>
</ol>
<p>Steps 2 and 3 are repeated until the location of the centroid for each cluster converges.</p>
<h3><a class="header" href="#using-kmeans-with-linfa-clustering" id="using-kmeans-with-linfa-clustering">Using KMeans with <code>linfa-clustering</code></a></h3>
<p>First, we'll start off by importing the dependencies, which can be found in the <code>Cargo.toml</code> file in the <code>code/</code> folder. Note that we need to include both the overall <code>linfa</code> crate, which will provide some of the structuring, as well as the actual KMeans algorithm from the <code>linfa-clustering</code> crate.</p>
<pre><pre class="playpen"><code class="language-rust no_run">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Import the linfa prelude and KMeans algorithm
use linfa::prelude::*;
use linfa_clustering::KMeans;
// We'll build our dataset on our own using ndarray and rand
use ndarray::prelude::*;
use rand::prelude::*;
// Import the plotters crate to create the scatter plot
use plotters::prelude::*;
<span class="boring">}
</span></code></pre></pre>
<p>After importing the dependencies, we'll start off by creating a set of data points that we want to cluster. This data could be imported from somewhere else through a library like <a href="https://github.com/paulkernfeld/ndarray-csv"><code>ndarray_csv</code></a> or <a href="https://github.com/ritchie46/polars"><code>polars</code></a>, but we'll create it manually here for this example. The most important thing is that we end up with an <code>ndarray</code> <code>Array2&lt;f32&gt;</code> data structure.</p>
<p>For this dataset, we'll get started with a few squares filled with random points, in which each square is defined by a center point, edge length, number of points contained within it's boundaries. Each of those squares should end up having a high-enough density to be the center point of one of our clusters. We'll also create a large, sparse set of points covering all over them to act as background noise, which will help to visually demonstrate how disparate points get assigned to clusters.</p>
<p>Since each of these squares is being created individually, we'll then need to consolidate them along (along the y-axis) by using the <code>ndarray::stack()</code> function, which concatenates arrays along the specified axis.</p>
<pre><pre class="playpen"><code class="language-rust no_run">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let square_1: Array2&lt;f32&gt; = create_square([7.0, 5.0], 1.0, 150); // Cluster 1
let square_2 = create_square([2.0, 2.0], 2.0, 150); // Cluster 2
let square_3 = create_square([3.0, 8.0], 1.0, 150); // Cluster 3
let square_4 = create_square([5.0, 5.0], 9.0, 300); // A bunch of noise across them all

let combined_squares = ndarray::stack(
Axis(0),
&amp;[
square_1.view(),
square_2.view(),
square_3.view(),
square_4.view(),
],
)
.expect(&quot;An error occurred while stacking the dataset&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Now that we have our data, we'll convert it into the form that linfa uses for training and predicting model, the <code>Dataset</code> type.</p>
<p>In order to actually build the KMeans algorithm, there are two additional things that we'll need: the number of clusters we're expecting, and a random number generator (RNG). While it is possible to manually define the starting location of each centroid, we often use KMeans in situations where we don't know much about the data ahead of time, so randomly creating them can work just as well. This represents one of the trade-offs of using KMeans; it will always converge towards a minima, it's just not guaranteed that is will be a <em>global</em> minima.</p>
<p>Using these variables, we can build our model, and set a few additional parameters that may be useful along the way. In this case, those parameters are the maximum number of iterations that we'll allow before stopping, and the tolerance in terms of distance between each iteration that we'll allow before considering our fit to have converged. Finally, we'll run the <code>fit()</code> method against the dataset.</p>
<pre><pre class="playpen"><code class="language-rust no_run">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let dataset = DatasetBase::from(combined_squares);
let rng = thread_rng(); // Random number generator
let n_clusters = 3;
let model = KMeans::params_with_rng(n_clusters, rng)
.max_n_iterations(200)
.tolerance(1e-5)
.fit(&amp;dataset)
.expect(&quot;Error while fitting KMeans to the dataset&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>In order to actually get the cluster assignments for the original dataset, however, we'll need to actually run the model against the dataset it was trained on. This may seem a little counter-intuitive, but this two-step process of <code>fit()</code> and <code>predict()</code> helps to make the overall modelling system more flexible.</p>
<p>Calling the <code>predict()</code> method will also convert the <code>dataset</code> variable from a single <code>Array2&lt;f32&gt;</code> in a pair of arrays <code>(records, targets): (Array2&lt;f32&gt;, Array1&lt;f32&gt;)</code>.</p>
<pre><pre class="playpen"><code class="language-rust no_run">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let dataset = model.predict(dataset);
println!(&quot;{:?}&quot;, dataset.records.shape());
println!(&quot;{:?}&quot;, dataset.targets.shape());
<span class="boring">}
</span></code></pre></pre>
<p>At this point, we have all of our points and their assigned clusters, and we can move onto doing some data visualization! The initial step in that process is setting up the backend, of which the <code>plotters</code> library has several. We'll use the <code>BitMapBackend</code>, which will save the chart we create into a <code>.png</code> image file with a specified name and size.</p>
<p>A <code>ChartBuilder</code> data structure will be laid on top of the backend, which will actually be responsible for the placing of chart elements like labels, margins, grids, etc. which are all defined by the user. In this case, we want to graph on a two-dimensional Cartesian plane, with both the x- and y-axes set to a range of <code>[0..10]</code>.</p>
<pre><pre class="playpen"><code class="language-rust no_run">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let root = BitMapBackend::new(&quot;../src/kmeans.png&quot;, (600, 400)).into_drawing_area();
root.fill(&amp;WHITE).unwrap();

let x_lim = 0.0..10.0f32;
let y_lim = 0.0..10.0f32;

let mut ctx = ChartBuilder::on(&amp;root)
.set_label_area_size(LabelAreaPosition::Left, 40) // Put in some margins
.set_label_area_size(LabelAreaPosition::Right, 40)
.set_label_area_size(LabelAreaPosition::Bottom, 40)
.caption(&quot;KMeans Demo&quot;, (&quot;sans-serif&quot;, 25)) // Set a caption and font
.build_cartesian_2d(x_lim, y_lim)
.expect(&quot;Couldn't build our ChartBuilder&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>The final part of this process consists of actually adding in the mesh, and setting up an area for plotting each of the individual data points.</p>
<pre><pre class="playpen"><code class="language-rust no_run">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>ctx.configure_mesh().draw().unwrap();
let root_area = ctx.plotting_area();
<span class="boring">}
</span></code></pre></pre>
<p>Before starting to plot, however, we want to make sure that the data we're going to plot is the right shape; a two-dimensional dataset with two columns. Fortunately, a simple helper function has been written to double-check if that is true.</p>
<pre><pre class="playpen"><code class="language-rust no_run">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// check_array_for_plotting(dataset: &amp;Array2&lt;f32&gt;) -&gt; bool {}
check_array_for_plotting(&amp;dataset.records); // Panics if that's not true
<span class="boring">}
</span></code></pre></pre>
<p>We're now ready to begin plotting! It is possible to plot elements as part of a series, but it's easy (and still quite fast) to do each individually. First, the coordinates from each element get pulled from the <code>dataset.records</code> array. Those coordinates are then used to create a dot, where we pattern-match on the point's assigned cluster from <code>dataset.targets</code> to choose the color.</p>
<p>Notice that the pattern-matching here is exhaustive! For KMeans, this isn't important, because each point is automatically assigned to a cluster. However, that's not necessarily true for all clustering algorithms, where some less-important data points can be left behind, so it's good practice to make sure that we consider that possibility. Finally, we'll actually draw the chart element we created using that information onto the chart area.</p>
<pre><pre class="playpen"><code class="language-rust no_run">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>for i in 0..dataset.records.shape()[0] {
let coordinates = dataset.records.slice(s![i, 0..2]);

let point = match dataset.targets[i] {
0 =&gt; Circle::new(
(coordinates[0], coordinates[1]),
3,
ShapeStyle::from(&amp;RED).filled(),
),
1 =&gt; Circle::new(
(coordinates[0], coordinates[1]),
3,
ShapeStyle::from(&amp;GREEN).filled(),
),

2 =&gt; Circle::new(
(coordinates[0], coordinates[1]),
3,
ShapeStyle::from(&amp;BLUE).filled(),
),
// Making sure our pattern-matching is exhaustive
_ =&gt; Circle::new(
(coordinates[0], coordinates[1]),
3,
ShapeStyle::from(&amp;BLACK).filled(),
),
};

root_area
.draw(&amp;point)
.expect(&quot;An error occurred while drawing the point!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>And that's it! Note that there's not separate step for saving the final product, since that's automatically taken care of by our backend. The final visualization of the clusters created by the KMeans algorithm will look like the following:</p>
<p><img src="kmeans.png" alt="KMeans" /></p>
<h1><a class="header" href="#bibliography" id="bibliography">Bibliography</a></h1>
<dl class="bib2xhtml"><!-- Authors: Amir Avni Boaz Rafaely --><dt><a id="iacc">[AA09]</a></dt><dd>Boaz Rafaely Amir Avni.Interaural cross correlation and spatial correlation in a sound field  represented by Spherical Harmonics.In <cite>Ambisonics Symposium</cite>, 2009.</dd><!-- Authors: Andeggs --><dt><a id="wikimedia">[And09]</a></dt><dd>Andeggs.<a href="https://upload.wikimedia.org/wikipedia/commons/4/4f/3D_Spherical.svg">3d  spherical coordinates</a>, 2009.[Online; accessed August 20, 2017].</dd><!-- Authors: Audio Research Lab --><dt><a id="step">[Aud16]</a></dt><dd>Audio Research Lab.<cite>Subjective Training and Evaluation Program (STEP)</cite>, 2016.</dd><!-- Authors: Boaz Rafaely --><dt><a id="sampling">[Boa15]</a></dt><dd>Rafaely Boaz.<cite>Fundementals of Spherical Array Processing</cite>.Springer, 2015.</dd><!-- Authors: Thomas Buelow --><dt><a id="convolution">[Bue01]</a></dt><dd>Thomas Buelow.Spherical diffusion for surface smoothing and denoising, 2001.</dd><!-- Authors: Clapp Samuel W and Guthrie Anne E and Braasch Jonas and Xiang  Ning --><dt><a id="maxre">[CGBX13]</a></dt><dd>Samuel W. Clapp,  Anne E. Guthrie, Jonas Braasch, and  Ning Xiang.Using Ambisonics to reconstruct measured soundfields.In <cite>Audio Engineering Society Convention 135</cite>, 2013.</dd><!-- Authors: Qing Chen --><dt><a id="imagemoments">[Che03]</a></dt><dd>Qing Chen.Evaluation of ocr algorithms for images with different spatial resolutions and  noises, 2003.</dd><!-- Authors: C Nachbar F Zotter E Deleflie and A Sontacchi --><dt><a id="ambix">[CNS11]</a></dt><dd>E. Deleflie C. Nachbar,  F. Zotter and A. Sontacchi.Ambix - a suggested ambisonics format.In <cite>Ambisonics Symposium</cite>, 2011.</dd><!-- Authors: Daniel Jerome --><dt><a id="nfc1">[Dan03]</a></dt><dd>Jerome Daniel.Spatial sound encoding including near field effect: Introducing distance coding  filters and a viable, new Ambisonic format.In <cite>Audio Engineering Society Conference: 23rd International Conference:  Signal Processing in Audio Recording and Reproduction</cite>, 2003.</dd><!-- Authors: DM Healy Jr D Rockmore P J Kostelec and Sean S B Moore --><dt><a id="shfft">[DHJM98]</a></dt><dd>P. J. Kostelec D.M.  Healy Jr., D. Rockmore and Sean S. B. Moore.FFTs for the 2-sphere - improvements and variation.<cite>Journal of Fourier Analysis and Applications</cite>, 9(4):341–385,  1998.</dd><!-- Authors: A R DiDonato --><dt><a id="legendreintegral">[DiD82]</a></dt><dd>A. R.  DiDonato.Recurrence relations for the indefinite integrals of the associated legendre  functions.<cite>Mathematics of Computation</cite>, 38(158):547–551, 1982.</dd><!-- Authors: Heinz W Engl --><dt><a id="tikhonov">[Eng87]</a></dt><dd>Heinz W Engl.On the choice of the regularization parameter for iterated tikhonov  regularization of iii-posed problems.<cite>Journal of Approximation Theory</cite>, 49(1):55–63, 1987.</dd><!-- Authors: Franz Zotter Matthias Frank and Hannes Pomberger --><dt><a id="modematchingsvd">[FZP13]</a></dt><dd>Matthias Frank  Franz Zotter and Hannes Pomberger.Comparison of energy-preserving and all-round Ambisonic decoders.In <cite>Fortschritte der Akustik, AIA-DAGA</cite>, 2013.</dd><!-- Authors: Herre Jürgen and Hilpert Johannes and Kuntz Achim and Plogsties  Jan --><dt><a id="mpegh">[HHKP15]</a></dt><dd>Jürgen Herre,  Johannes Hilpert, Achim Kuntz, and  Jan Plogsties.MPEG-H audio—the new standard for universal spatial/3d audio coding.<cite>J. Audio Eng. Soc</cite>, 62:821–830, 2015.</dd><!-- Authors: R H Hardin and N J A Sloane --><dt><a id="hardinsloane">[HS96]</a></dt><dd>R. H. Hardin and  N. J. A. Sloane.Mclaren's improved snub cube and other new spherical designs in three  dimensions.<cite>Discrete Computational Geometry</cite>, 15:429–441, 1996.</dd><!-- Authors: Hahn Nara and Spors Sascha --><dt><a id="nfc2">[HS17]</a></dt><dd>Nara Hahn and  Sascha Spors.Further investigations on the design of radial filters for the driving  functions of Near-Field Compensated Higher-Order Ambisonics.In <cite>Audio Engineering Society Convention 142</cite>, 2017.</dd><!-- Authors: M A Poletti --><dt><a id="modematching">[Pol05]</a></dt><dd>M. A. Poletti.Three-dimensional surround sound systems based on Spherical Harmonics.<cite>J. Audio Eng. Soc</cite>, 53(11):1004–1025, 2005.</dd><!-- Authors: Lord Rayleigh --><dt><a id="itdild">[Ray07]</a></dt><dd>Lord Rayleigh.On our perception of sound direction.13(74):214–232, 1907.</dd><!-- Authors: Scaini Davide and Arteaga Daniel --><dt><a id="idhoa">[SA14]</a></dt><dd>Davide Scaini and  Daniel Arteaga.Decoding of higher order ambisonics to irregular periphonic loudspeaker arrays.In <cite>Audio Engineering Society Conference: 55th International Conference:  Spatial Audio</cite>, Aug 2014.</dd><!-- Authors: Sakurai JJ and Napolitano J --><dt><a id="clebschgordan">[SN11]</a></dt><dd>J.J. Sakurai and  J. Napolitano.<cite>Modern Quantum Mechanics</cite>.Pearson, 2011.</dd><!-- Authors: Ville Pulkki Jyri Huopaniemi Tommi Huotilainen and Matti  Karjalainen --><dt><a id="vbap">[vba96]</a></dt><dd><cite>DSP Approach to Multichannel  Audio Mixing</cite>. ICMC, 1996.</dd><!-- Authors: Peter Young --><dt><a id="helmholtz">[You09]</a></dt><dd>Peter Young.Helmholtz's and laplace's equations in spherical polar coordinates: Spherical  harmonics and spherical Bessel functions, 2009.</dd><!-- Authors: Zotter Franz and Frank Matthias --><dt><a id="allrad">[ZF12]</a></dt><dd>Franz Zotter and  Matthias Frank.All-round Ambisonic panning and decoding.<cite>J. Audio Eng. Soc</cite>, 60(10):807–820, 2012.</dd><!-- Authors: Franz Zotter and Hannes Pomberger --><dt><a id="modematchingimprove">[ZP10]</a></dt><dd>Franz  Zotter and Hannes Pomberger.Ambisonic decoding with and without Mode-Matching: A case study using the  hemisphere.2010.</dd>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
